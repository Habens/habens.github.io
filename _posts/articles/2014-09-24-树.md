---
layout: post
title: 树
author: habens_chen
modified:
categories: articles
excerpt:
tags: [树, tree]
image:
  feature:
comments: true
share: true
date: 2014-09-24T23:52:21+08:00
---

在提及拓扑之前，我想必须先要讲讲接下来这几个家伙：

* Table of Contents
{:toc}

## 查询二叉树

插入：当存在相同值时，插到原结点的右子结点处。

删除：选择左子树最大字结点替代，或者右子树最小结点替代。

理由：我们在插入和删除结点时，不应当（或者说应尽可能小的）破坏原本的树结构。


## 堆

建立：

* 方法一：将新元素V放到末尾位置，将其与其父结点相比较，以使它移到正确位置。

* 方法二（较优）：假设左、右子树都已经是堆，并且根元素为R。如果R不是在正确的位置上，那么就不断的把R往下拉（与两个字结点中较大的交换）。


## Huffman树

建立：为每个结点赋予一个权值并按权值排序。从权值中找出最小的两个结点，合成一个子树，该子树根结点的权值为两结点权值的和。然后将该跟结点当作普通结点与剩下的结点进行排序。然后重复刚才的行为，从排序后的序列里选出最小的两个结点，再次合成一个子树。以此类推。


## 树

### 父结点指示法

对每个结点只保存一个指针指向其父结点。

该方法可以解答“给出两个结点，它们是否在统一棵树中？”的问题。如果它们向上到达同一个根，既是在同一树中，反之则不是。

父指针通常用于维护由一些不相交子集构成的集合，包含两种基本操作UNIN/FIND（并查算法）：

* 判断两个结点是否在同一集合中（是否是一个根）

* 归并两个集合（将两个等价归并起来）

归并（形成尽量浅的树）：

* 重量权衡合并法则（weighted union tule）：把结点较少的树与结点较多的树合并时，将结点较少的树的根结点指向结点较多的树的根结点。

* 路径压缩（在FIND操作中完成）：设根结点为R，则把由X到R的路径上每个结点的父指针域直接指向R。


### 子结点表示法（数组）

每个结点包含结点值、一个父指针以及一个指向子结点链表的指针。


### 左子结点/右兄弟结点表示法（数组）

每个结点存储结点的值，以及指向父结点、最左子结点和右侧兄弟结点的指针

理由：子结点表示法使得存取一个结点的右侧兄弟结点较为困难。


### 动态结点表示法（ 链表）

* 方法一：对每个结点分配相同的指针域

缺点：

   + 对子结点的数目加上了不必要的限制

   + 空间的浪费

应用场景：在一个结点生成时就知道它的子结点数目。

* 方法二：为每个结点分配可变的存储空间

### 动态左子结点/右结点表示法


## K叉树

## 树的顺序表示：

* AB/D//CEG///FH//I// （‘/’表示空指针）

* RAC)D)E)BF))) （‘）’表示叶结点，如果一个叶结点是父结点的最后一个结点，就多跟一个‘）’）
