---
layout: post
title: The Basic Data Struct and Algorithms
author: habens_chen
modified:
categories: articles
excerpt:
tags: [tree, struct, algorithm]
image:
  feature:
comments: true
share: true
date: 2014-09-24T23:52:21+08:00
---

这些是一些基础的数据结构与算法知识，虽然基础，但却要用代码实现却还是有很多需要我们十分注意的许多细节。借用此篇博文，做为一个复习的记录。

* Table of Contents
{:toc}

## 1. 查询二叉树

插入：当存在相同值时，插到原结点的右子结点处。<br>
删除：选择左子树最大字结点替代，或者右子树最小结点替代。<br>
理由：我们在插入和删除结点时，不应当（或者说应尽可能小的）破坏原本的树结构。<br>


## 2. 堆

建立：<br>

* 方法一：将新元素V放到末尾位置，将其与其父结点相比较，以使它移到正确位置。<br>
* 方法二（较优）：假设左、右子树都已经是堆，并且根元素为R。如果R不是在正确的位置上，那么就不断的把R往下拉（与两个字结点中较大的交换）。<br>


## 3. Huffman树

建立：为每个结点赋予一个权值并按权值排序。从权值中找出最小的两个结点，合成一个子树，该子树根结点的权值为两结点权值的和。然后将该跟结点当作普通结点与剩下的结点进行排序。然后重复刚才的行为，从排序后的序列里选出最小的两个结点，再次合成一个子树。以此类推。<br>


## 4. 树

### 4.1 父结点指示法

对每个结点只保存一个指针指向其父结点。<br>
该方法可以解答“给出两个结点，它们是否在统一棵树中？”的问题。如果它们向上到达同一个根，既是在同一树中，反之则不是。<br>
父指针通常用于维护由一些不相交子集构成的集合，包含两种基本操作UNIN/FIND（并查算法）：<br>

* 判断两个结点是否在同一集合中（是否是一个根）<br>
* 归并两个集合（将两个等价归并起来）<br>

归并（形成尽量浅的树）：<br>

* 重量权衡合并法则（weighted union tule）：把结点较少的树与结点较多的树合并时，将结点较少的树的根结点指向结点较多的树的根结点。<br>
* 路径压缩（在FIND操作中完成）：设根结点为R，则把由X到R的路径上每个结点的父指针域直接指向R。<br>

### 4.2 子结点表示法（数组）

每个结点包含结点值、一个父指针以及一个指向子结点链表的指针。<br>

### 4.3 左子结点/右兄弟结点表示法（数组）

每个结点存储结点的值，以及指向父结点、最左子结点和右侧兄弟结点的指针<br>
理由：子结点表示法使得存取一个结点的右侧兄弟结点较为困难。<br>

### 4.4 动态结点表示法（ 链表）

* 方法一：对每个结点分配相同的指针域<br>
 缺点:

   1. 对子结点的数目加上了不必要的限制

   2. 空间的浪费

   应用场景：在一个结点生成时就知道它的子结点数目。<br>

* 方法二：为每个结点分配可变的存储空间<br>

### 4.5 动态左子结点/右结点表示法


## 5. K叉树


## 6. 树的顺序表示：

* AB/D//CEG///FH//I// （‘/’表示空指针）<br>
* RAC)D)E)BF))) （‘）’表示叶结点，如果一个叶结点是父结点的最后一个结点，就多跟一个‘）’）
